#!/usr/bin/env bash

########## set debug options ##########

set -u # undefined variables error

#######################################

########## inicialize ##########

POSIXLY_CORRECT=yes
LC_CTYPE=C
IFS=' '
USAGE_STRING=$(printf "usage:\n\t$0 [-i FILE_ERE] [-n] [DIR]")
NORMALIZATION=0
REGEXP=''
DIR=$(pwd)
ND=0
NF=0

declare -A FSH
FSH["<100B"]=0
FSH["<1KiB"]=0
FSH["<10KiB"]=0
FSH["<100KiB"]=0
FSH["<1MiB"]=0
FSH["<10MiB"]=0
FSH["<100MiB"]=0
FSH["<1GiB"]=0
FSH[">=1GiB"]=0

declare -A FTH

################################

########## process arguments ##########

while getopts i:n option
do
	case "$option" in
	i)
		REGEXP="$OPTARG"
		;;
	n)
		NORMALIZATION=1
		;;
	*)
		echo "$USAGE_STRING" >&2
		exit 1
		;;
	esac
done

# shift arguments
(( OPTIND-- ))
shift $OPTIND

# there are too many arguments
if [ $# -gt 1 ]; then
	echo "$USAGE_STRING" >&2
	exit 1
fi

# set DIR param
if [ $# -eq 1 ]; then
	DIR="$1"
fi

######################################

########## error checks ##########

# check if FILE_ERE cover root dir
if [ "$REGEXP" ]; then
	if printf "$DIR" | grep -qE "$REGEXP"; then
		echo "$0: FILE_ERE must not cover name of root directory." >&2
		exit 1
	fi
fi


# check if direcotry exists
if [ ! -d "$DIR" ]; then
	echo "$0: Given directory: $DIR does not exists." >&2
	exit 1
fi

###################################

########## process files ##########

if [ "$REGEXP" ]; then
	dir_length_replace="${#DIR}"
	(( dir_length_replace++ ))
fi

while read file
do
	ignore=0
	if [ "$REGEXP" ]; then
		# ignore files and all files in subdirectories specified in REGEXP
		relative_file_name=$(printf "$file" | cut -c $dir_length_replace-)
		if [ "$file" != "$relative_file_name" ]; then
			IFS='/'
			for part in $relative_file_name
			do
				IFS=' '
				if printf "$part" | grep -qE "$REGEXP"; then
					ignore=1			
				fi
			done
			IFS=' '

			if [ "$ignore" -eq 1 ]; then
				continue
			fi
		fi
	fi

	if [ -d "$file" ]; then
		(( ND++ ))
	elif [ -f "$file" ]; then
		(( NF++ ))

		size=$(wc -c < "$file" | xargs)
		if [ "$size" -lt 100 ]; then
			(( FSH["<100B"]++ ))
		elif [ "$size" -lt 1024 ]; then
			(( FSH["<1KiB"]++ ))
		elif [ "$size" -lt 10240 ]; then
			(( FSH["<10KiB"]++ ))
		elif [ "$size" -lt 102400 ]; then
			(( FSH["<100KiB"]++ ))
		elif [ "$size" -lt 1048576 ]; then
			(( FSH["<1MiB"]++ ))
		elif [ "$size" -lt 10485760 ]; then
			(( FSH["<10MiB"]++ ))
		elif [ "$size" -lt 10485760 ]; then
			(( FSH["<100MiB"]++ ))
		elif [ "$size" -lt 1073741824 ]; then
			(( FSH["<1GiB"]++ ))
		elif [ "$size" -ge 1073741824 ]; then
			(( FSH[">=1GiB"]++ ))
		fi
		
		file_type=$(file -b "$file")
		file_type_chars=${#file_type}
		if [ "$file_type_chars" -gt 40 ]; then
			file_type=$(printf "$file_type" | cut -c -40)
			file_type=$(printf '%s...' "$file_type")
		fi
		if [ "${FTH[$file_type]+exists}" ]; then
			FTH["$file_type"]=$(( ${FTH["$file_type"]} + 1 ))
		else
			FTH["$file_type"]=1
		fi
	fi
done <<< $(find "$DIR" -type f -or -type d)

###################################

function normalization
{
	line_length=79
	if [ -t 1 ]; then
		line_length=$(tput cols)
		(( line_length-- ))
	fi

	max_hashes=$(( line_length - $2))
	if [ $max_hashes -lt $3 ]; then
		max_hashes=$3
	fi

	max_count=0
	values=$(eval echo \${$1[*]})
	for c in $values
	do
		if [ $max_count -lt $c ]; then
			max_count=$c
		fi
	done

	used_line_length=$(( max_count + $2 ))
	if [ $used_line_length -gt $line_length ]; then
		if [ ! $max_count -eq 0 ]; then
			IFS=$'\n'
			keys=$(eval echo \"\${!$1[*]}\")
			for type in $keys
			do
				IFS=' '
				eval $1["$type"]=$(( $1["$type"] * 100 / max_count * max_hashes / 100 ))
			done
			IFS=' '
		fi
	fi
}

if [ $NORMALIZATION -eq 1 ]; then
	normalization 'FSH' 12 9
	normalization 'FTH' 47 10
fi

########## output ##########

function print_hashes
{
	if [ "$1" -ne 0 ]; then
		eval printf '\#%.0s' {1.."$1"}
	fi
	printf '\n'
}

function print_FTH
{
	sorted=$(
		for file_type in "${!FTH[@]}"
		do
			echo "${FTH[$file_type]}~$file_type"
		done | sort -k 1,1 -n -r -t ' '
	)

	i=0
	while read -r line
	do
		if [ "$i" -ge $1 ]; then
			break
		fi

		(( i++ ))

		value=$(printf "$line" | sed 's/\(^.*\)~.*/\1/')
		file_type=$(printf "$line" | sed 's/^.*~\(.*\)/\1/')
		
		if [ "$value" ]; then
			printf '  %-43s: ' "$file_type"; print_hashes "$value"
		fi
	done <<< "$sorted"
}

echo "Root directory: $DIR"
echo "Directories: $ND"
echo "All files: $NF"

echo "File size histogram:"
printf "  <100 B  : " ; print_hashes "${FSH[<100B]}"
printf "  <1 KiB  : " ; print_hashes "${FSH[<1KiB]}"
printf "  <10 KiB : " ; print_hashes "${FSH[<10KiB]}"
printf "  <100 KiB: " ; print_hashes "${FSH[<100KiB]}"
printf "  <1 MiB  : " ; print_hashes "${FSH[<1MiB]}"
printf "  <10 MiB : " ; print_hashes "${FSH[<10MiB]}"
printf "  <100 MiB: " ; print_hashes "${FSH[<100MiB]}"
printf "  <1 GiB  : " ; print_hashes "${FSH[<1GiB]}"
printf "  >=1 GiB : " ; print_hashes "${FSH[>=1GiB]}"

echo "File type histogram:"
print_FTH 10

############################
