#!/usr/bin/env bash

########## set debug options ##########

set -u # undefined variables error

#######################################

########## inicialize ##########

POSIXLY_CORRECT=yes
USAGE_STRING=$(printf "usage:\n\t$0 [-i FILE_ERE] [-n] [DIR]")
NORMALIZATION=0
REGEXP=''
DIR=$(pwd)
ND=0
NF=0

declare -A FSH
FSH["<100B"]=0
FSH["<1KiB"]=0
FSH["<10KiB"]=0
FSH["<100KiB"]=0
FSH["<1MiB"]=0
FSH["<10MiB"]=0
FSH["<100MiB"]=0
FSH["<1GiB"]=0
FSH[">=1GiB"]=0

declare -A FTH

################################

########## process arguments ##########

while getopts i:n option
do
	case "$option" in
	i)
		REGEXP="$OPTARG"
		;;
	n)
		NORMALIZATION=1
		;;
	*)
		echo "$USAGE_STRING" >&2
		exit 1
		;;
	esac
done

# shift arguments
(( OPTIND-- ))
shift $OPTIND

# there are too many arguments
if [ $# -gt 1 ]; then
	echo "$USAGE_STRING" >&2
	exit 1
fi

# set DIR param
if [ $# -eq 1 ]; then
	DIR="$1"
fi

######################################

##### check if FILE_ERE cover root dir #####

if [ "$REGEXP" ]; then
	if printf "$DIR" | grep -qE "$REGEXP"; then
		echo "$0: FILE_ERE must not cover name of root directory." >&2
		exit 1
	fi
fi


############################################

########## process files ##########

if [ "$REGEXP" ]; then
	dir_length_replace="${#DIR}"
	(( dir_length_replace++ ))
fi

while read file
do
	ignore=0
	if [ "$REGEXP" ]; then
		# ignore files and all files in subdirectories specified in REGEXP
		relative_file_name=$(printf "$file" | cut -c $dir_length_replace-)
		if [ "$file" != "$relative_file_name" ]; then
			IFS='/'
			for part in $relative_file_name
			do
				unset IFS
				if printf "$part" | grep -qE "$REGEXP"; then
					ignore=1			
				fi
			done
			unset IFS

			if [ "$ignore" -eq 1 ]; then
				continue
			fi
		fi
	fi

	if [ -d "$file" ]; then
		(( ND++ ))
	elif [ -f "$file" ]; then
		(( NF++ ))

		size=$(wc -c < "$file" | xargs)
		if [ "$size" -lt 100 ]; then
			(( FSH["<100B"]++ ))
		elif [ "$size" -lt 1024 ]; then
			(( FSH["<1KiB"]++ ))
		elif [ "$size" -lt 10240 ]; then
			(( FSH["<10KiB"]++ ))
		elif [ "$size" -lt 102400 ]; then
			(( FSH["<100KiB"]++ ))
		elif [ "$size" -lt 1048576 ]; then
			(( FSH["<1MiB"]++ ))
		elif [ "$size" -lt 10485760 ]; then
			(( FSH["<10MiB"]++ ))
		elif [ "$size" -lt 10485760 ]; then
			(( FSH["<100MiB"]++ ))
		elif [ "$size" -lt 1073741824 ]; then
			(( FSH["<1GiB"]++ ))
		elif [ "$size" -ge 1073741824 ]; then
			(( FSH[">=1GiB"]++ ))
		fi
		
		file_type=$(file -b "$file")
		file_type_chars=${#file_type}
		if [ "$file_type_chars" -gt 40 ]; then
			file_type=$(printf "$file_type" | cut -c -40)
			file_type=$(printf '%s...' "$file_type")
		else
			file_type=$(printf '%-43s' "$file_type")
		fi
		if [ "${FTH[$file_type]+exists}" ]; then
			(( FTH["$file_type"]++ ))
		else
			FTH["$file_type"]=0
		fi
	fi
done <<__END__
$(find "$DIR" -type f -or -type d)
__END__

###################################

function sort_associative_array_by_value
{
	typeset sorted=($(
		for file_type in "${!FTH[@]}"
		do
			echo "${FTH[$file_type]} $file_type"
		done | sort -k 1,1 -n -r -t ' '
	))

	unset FTH
	declare -A FTH
	typeset key=''
	typeset value=''
	
	for line in "${sorted[@]}"
	do
		value=$(printf "$line" | sed 's/\(^[^ ]*\).*/\1/')
		key=$(printf "$line" | sed 's/^[^ ]* \(.*\)/\1/')
		FTH["$key"]="$value"
		echo "$line"
	done

}

#sort_associative_array_by_value "FTH"

########## output ##########

function print_hashes
{
	if [ "$1" -ne 0 ]; then
		eval printf '\#%.0s' {1.."$1"}
	fi
	printf '\n'
}

echo "Root directory: $DIR"
echo "Directories: $ND"
echo "All files: $NF"

echo "File size histogram:"
printf "  <100 B  : " ; print_hashes "${FSH[<100B]}"
printf "  <1 KiB  : " ; print_hashes "${FSH[<1KiB]}"
printf "  <10 KiB : " ; print_hashes "${FSH[<10KiB]}"
printf "  <100 KiB: " ; print_hashes "${FSH[<100KiB]}"
printf "  <1 MiB  : " ; print_hashes "${FSH[<1MiB]}"
printf "  <10 MiB : " ; print_hashes "${FSH[<10MiB]}"
printf "  <100 MiB: " ; print_hashes "${FSH[<100MiB]}"
printf "  <1 GiB  : " ; print_hashes "${FSH[<1GiB]}"
printf "  >=1 GiB : " ; print_hashes "${FSH[>=1GiB]}"

echo "File type histogram:"
for file_type in "${!FTH[@]}"
do
	printf "  $file_type: "; print_hashes "${FTH[$file_type]}"
done

############################
